#ifndef _ABSTRACT_MAP_H
#define _ABSTRACT_MAP_H

/*
Base class for all maps which are to be supported by the framework.

In order to provide flexibility in terms of actual map implementation, the
framework allows each map to define its own update operations over the map,
which we refer to as `MapUpdate`s. Agents are required to 'tag' each update,
where the 'tag' is a part of the contract that each map implementation has 
to provide to agents. A requirement of the tag contract is that map updates
corresponding to different tags have no dependencies, and can thereby be
executed concurrently. For example, a natural tag definition for a 2D gridworld
is the grid cell position (x,y).

All subclasses are required to implement virtual methods.
*/

#include "abstract_grid_position.h"
#include "abstract_updates.h"


enum AgentMethod {
  RANDOM, DETERMINISTIC
};

class AbstractMap {
  private:
  public:
    AbstractMap(bool use_gpu=false);
    
    /*
     * Interface supplied by subclasses for concrete map implementation.

     * Tags are defined by the subclasses, with the understanding that map updates
     * corresponding to different tags are independent and can be executed
     * concurrently. The map updates generated by all the agents for a particular
     * tag are efficiently collated, and tag updates are performed.

     * If there is shared state that needs to be updated for each tag, the
     * implementation is responsible for ensuring correctness under concurrent
     * updates. Furthermore, any checking for invalid tags also has to be
     * performed by the supplied class.

     * Parameters
     * ----------
     * tag: object, required
     *     The implementation-defined value for tag, such that tags are independent
     *     of each other.
     * mapUpdatesList: list of MapUpdate objects, required
     *    List of implementation-defined map-update operations. It is up to the
     *    business logic to implement the updates.
     */
    void doTaggedMapUpdates(AbstractPosition *active_position, \
                            std::vector<AbstractUpdate*> map_updates);
    /*
     * Interface supplied by subclasses allowing agents to
     * reference their own map information.
     *
     * Parameters
     * ----------
     * agent: object, required
     * The agent's self object, used for referencing the environment
     * 
     * Returns
     * -------
     * agent_map_info: object, required
     * Map-specific agent information (for instance, for a 2D grid world, \
     * this would be the position)
     */
    virtual std::unordered_map<AbstractAgent, AbstractPosition> getAgentMapInfo() = 0;

    /*
     * Observation returned to the client, at the end of step.
     *
     * Can be identity, or something more complex, depending on the environment.
     */
    virtual AbstractMap *getObservation() {
      return this;
    }

    /* Method to register agent. */
    virtual void registerAgent(AbstractAgent agent, AgentMethod method) = 0;
  
    /*
     * Method performing dispatch of tags to implementation.
     *
     * This is meant to support parallel dispatch.
     */
    void doMapUpdates(std::unordered_map<AbstractPosition *, AbstractUpdate *> list_of_updates) {
        return;
    }

  /* Simple helper functions */
  private:
    /* ==== MEMBERS ==== */

    /* Have a mapping for each agent to its position */
    std::unordered_map<AbstractAgent *, AbstractPosition *> agent_to_pos;
    std::unordered_map<AbstractPosition *, std::vector<AbstractAgent *> > pos_to_agents;
    
    /* ==== METHODS ==== */
  
    /* Sequentially update the agents */
    virtual void doSeqTaggedMapUpdates(AbstractPosition *tag,\
                                         std::vector<AbstractUpdate*> map_updates) = 0;
    
    /* See if the requested agent is currently present in this map */
    inline virtual bool isAgentInMap(AbstractAgent *agent) {
      return (agent_to_pos.count(agent) > 0);
    }

    virtual bool isValidPosition(AbstractPosition *position) {
      return (pos_to_agents.count(position) > 0);
    }

    virtual AbstractPosition *getAgentPosition(AbstractAgent *agent) {
      if (isAgentInMap(agent) == false) {
        return nullptr;
      }

      return agent_to_pos[agent];
    }

    virtual bool isAgentInPos(AbstractAgent *agent, AbstractPosition *position){
      return isAgentInMap(agent) && isValidPosition(position) && \
        (std::count(pos_to_agents[position].begin(), pos_to_agents[position].end(),
                    agent) > 0);
    }

    inline virtual void RemoveAgentFromRecords(AbstractAgent *agent) {
      if (isAgentInMap(agent) == false) {
        return;
      }

      AbstractPosition *loc = agent_to_pos[agent];

      /* Remove the agent from the agent->pos mapping */
      agent_to_pos.erase(agent);
      
      /* Remove the agent from the pos->agent mapping */
      pos_to_agents[loc].erase(std::remove(pos_to_agents[loc].begin(), \
            pos_to_agents[loc].end(), agent), pos_to_agents[loc].end());

      delete agent;

      return;
    }

    virtual void AddAgentToRecords(AbstractAgent *agent, AbstractPosition *pos) {
      /* Don't double add the agent to the map records */
      if (isAgentInMap(agent) == true)
        return;

      agent_to_pos[agent] = pos;
      pos_to_agents[pos].push_back(agent);
      return;
    }
};

#endif
